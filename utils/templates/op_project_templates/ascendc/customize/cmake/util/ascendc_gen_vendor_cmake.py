"""
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
# Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved.
"""

import os
import re
import argparse

CONFIG_CONTEXT = """
include(CMakeFindDependencyMacro)

include("${CMAKE_CURRENT_LIST_DIR}/##{replace_op}##-targets.cmake")

set(##{replace_op}##_VERSION 1.0.0)
set(##{replace_op}##_VERSION_COMPATIBLE 1.0.0)
"""

TARGETS_CONTEXT = """
#Generated by CMake

if("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.6)
  message(FATAL_ERROR "CMake >= 2.6.0 required")
endif()
cmake_policy(PUSH)
cmake_policy(VERSION 2.6...3.20)
#----------------------------------
# Generated CMake target import file.
#----------------------------------

# Commands may need to know the format version.
set(CMAKE_IMPORT_FILE_VERSION 1)

#Protect against multiple inclusion, which would fail when already imported targets are added once more.
set(_targetsDefined)
set(_targetsNotDefined)
set(_expectedTargets)
foreach(_expectedTarget ##{replace_op}##::static ##{replace_op}##::shared)
  list(APPEND _expectedTargets ${_expectedTarget})
  if(NOT TARGET ${_expectedTarget})
    list(APPEND _targetsNotDefined ${_expectedTarget})
  endif()
  if(TARGET ${_expectedTarget})
    list(APPEND _targetsDefined ${_expectedTarget})
  endif()
endforeach()
if("${_targetsDefined}" STREQUAL "${_expectedTargets}")
  unset(_targetsDefined)
  unset(_targetsNotDefined)
  unset(_expectedTargets)
  set(CMAKE_IMPORT_FILE_VERSION)
  cmake_policy(POP)
  return()
endif()
if(NOT "${_targetsDefined}" STREQUAL "")
  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\\nTargets Defined: ${_targetsDefined}\\nTargets not yet defined: ${_targetsNotDefined}\\n")
endif()
unset(_targetsDefined)
unset(_targetsNotDefined)
unset(_expectedTargets)


#Compute the installation prefix relative to this file.
get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
if(_IMPORT_PREFIX STREQUAL "/")
  set(_IMPORT_PREFIX "")
endif()

#Check CANN env
if (NOT DEFINED ENV{ASCEND_HOME_PATH})
    message(STATUS "Cannot found CANN env ASCEND_HOME_PATH, please check and reset")
    return()
endif()

set(_ASCEND_HOME_PATH $ENV{ASCEND_HOME_PATH})

add_library(_asc_##{replace_op}##_static STATIC IMPORTED)
set_target_properties(_asc_##{replace_op}##_static PROPERTIES
    IMPORTED_LOCATION "${_IMPORT_PREFIX}/lib/lib##{static_lib_name}##.a"
    INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
)

add_library(_asc_##{replace_op}##_base_deps INTERFACE)
set_target_properties(_asc_##{replace_op}##_base_deps PROPERTIES
    INTERFACE_LINK_DIRECTORIES "${_ASCEND_HOME_PATH}/lib"
    INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:ascendcl>;\$<LINK_ONLY:nnopbase>;\$<LINK_ONLY:exe_graph>;\$<LINK_ONLY:register>;\$<LINK_ONLY:tiling_api>;-Wl,--push-state,--whole-archive -lrt2_registry -Wl,--pop-state"
)

add_library(_asc_intf_##{replace_op}##_static INTERFACE)
add_library(##{replace_op}##::static ALIAS _asc_intf_##{replace_op}##_static)
set_target_properties(_asc_intf_##{replace_op}##_static PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
    INTERFACE_LINK_LIBRARIES "-Wl,--push-state,--whole-archive $<TARGET_PROPERTY:_asc_##{replace_op}##_static,IMPORTED_LOCATION> -Wl,--pop-state;\$<LINK_ONLY:_asc_##{replace_op}##_base_deps>"
)

# shared library
add_library(##{replace_op}##::shared SHARED IMPORTED)
set_target_properties(##{replace_op}##::shared PROPERTIES
    IMPORTED_LOCATION "${_IMPORT_PREFIX}/lib/lib##{dynamic_lib_name}##.so"
    INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
)

if(CMAKE_VERSION VERSION_LESS 2.8.12)
  message(FATAL_ERROR "This file relies on consumers using CMake 2.8.12 or greater.")
endif()


#Commands beyond  this point should not need to know the version.
set(CMAKE_IMPORT_FILE_VERSION)
cmake_policy(POP)
"""


def make_config_file(filename, output_dir):
    output_config_file = os.path.join(output_dir, f"{filename}-config.cmake")
    os.makedirs(output_dir, exist_ok=True)

    content = re.sub(r"##{replace_op}##", filename, CONFIG_CONTEXT.strip())
    with open(output_config_file, "w") as f:
        f.write(content)


def make_targets_file(filename, output_dir, static_lib_name, dynamic_lib_name):
    output_targets_file = os.path.join(output_dir, f"{filename}-targets.cmake")
    os.makedirs(output_dir, exist_ok=True)

    values = {"replace_op": filename, "static_lib_name": static_lib_name, "dynamic_lib_name": dynamic_lib_name}
    content = TARGETS_CONTEXT.strip()
    for key in sorted(values, key=lambda x: len(x), reverse=True):
        content = re.sub(f"##{{{key}}}##", values.get(key, ""), content)

    with open(output_targets_file, "w") as f:
        f.write(content)


def args_parse():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-v", "--vendor-name", help="Vendor name for cmake file."
    )
    parser.add_argument(
        "-o", "--output-path", help="Ouput path for cmake file."
    )
    parser.add_argument(
        "-s", "--static-lib-name", help="Static lib name."
    )
    parser.add_argument(
        "-d", "--dynamic-lib-name", help="Dynamic lib name."
    )
    return parser.parse_args()


def main():
    try:
        args = args_parse()

        make_config_file(args.vendor_name, args.output_path)
        make_targets_file(args.vendor_name, args.output_path, args.static_lib_name, args.dynamic_lib_name)
    except Exception as e:
        raise(e)


if __name__ == "__main__":
    main()